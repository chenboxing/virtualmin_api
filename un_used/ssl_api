require 'sinatra/base'
require 'webrick'
require 'webrick/https'
require 'openssl'
require 'json'
require 'logger'
require 'digest/md5'
require 'yaml'
require 'base64'
require 'logger'
require 'cgi'

require "#{File.dirname(__FILE__)}/virtual_api"

dir_path = File.dirname(__FILE__)

@@settings = YAML.load_file("#{dir_path}/settings.yml")

#Logger.new(STDOUT)
#　logger = Logger.new('foo.log', 10, 1024000) #保留10个日志文件，每个文件大小1024000字节
@@logger = Logger.new("#{dir_path}/logs/sinatra_api.log", 'daily') #按天生成
@@logger.level = Logger::INFO #fatal、error、warn、info、debug
# logger.formatter = proc { |severity, datetime, progname, msg|
#   "#{datetime}: #{msg}\n"
# }
#logger.info 'asdfasd'


cert = OpenSSL::X509::Certificate.new File.read File.join(File.dirname(__FILE__), 'certs', 'server.crt')
pkey = OpenSSL::PKey::RSA.new(
    File.open( File.join(File.dirname(__FILE__), 'certs', 'server.key')).read)

log_file = File.open "#{dir_path}/logs/webrick.log",'a+'
webrick_options = {
    :Port               => 3008,
    :ServerType         => WEBrick::SimpleServer, #WEBrick::Daemon or WEBrick::SimpleServer
    #:Logger => WEBrick::Log.new(log_file),
    #:AccessLog => [[log_file,WEBrick::AccessLog::COMBINED_LOG_FORMAT]],
    :SSLEnable          => true,
    :SSLVerifyClient    => OpenSSL::SSL::VERIFY_NONE,
    :SSLCertificate     => cert,
    :SSLPrivateKey      => pkey
}

class MyServer < Sinatra::Base 
 before do
    content_type :json
    #(status,message) = authenticate()
    # if status == 0
    #   result = {status:'failure',
    #       message:message,
    #       command:'authenticate'}
    #
    #s
    #   @@logger.info result.to_json
    #   halt 401, {content_type: 'text/json'}, result.to_json
    # end
  end

    get '/' do
        domain = params[:domain]
        #params.to_json
        #query_str = build_remote_api_url('list_domains',['domain','info'])

        remote_ip = request.env['REMOTE_ADDR']
        #request.env.to_json
        #query_str
        "Hello World!\n"
    end

    get '/test' do
      hash = {username: 'chen', age: 23, email:'c_boxing@hotmail.com',staffs:[{username:'huang',age:25}]}
      hash.to_json
    end


    get '/hostings' do
      api_method = 'list-domains'
      arguments = ['domain']
      data_json = call_remote_api(api_method, arguments)
      data_json
    end

    # 参数说明
    # domain 域名 比如seo138.com 或二级域名 w131111.seo138.com
    # user   用户名  不填，系统根据域名自动产生
    # pass   密码    必填
    # template  模板名 ，可选，默认模板
    # plan      帐号计划,可远，默认
    # desc      描述信息,可选
    # email     联系人Email,可选
    # mysql     是否开启mysql
    # ssl       是否启用ssl网站
    # db        数据库名称  可选
    # mysql-pass mysql密码
    post '/hosting/new' do
      api_method = 'create-domain'
      arguments = ['domain',
                   'user',
                   'pass',
                   'desc',
                   'email',
                   'ssl',
                   'mysql',
                   'virtualmin-awstats',
                   'template',
                   'plan',
                    'unix',
                    'dir',
                    'web',
                    'limits-from-plan',
                   'db',
                   'mysql-pass']
      data_json = call_remote_api(api_method, arguments)
      data_json
    end

    patch 'hosting/edit' do 
    
    end 

    delete '/domain' do
      api_method = 'delete-domain'
      arguments = ['domain','user','only']
      data_json = call_remote_api(api_method, arguments)
      data_json
    end

    get '/enable_domain' do
      api_method = 'enable-domain'
      arguments = ['domain']
      data_json = call_remote_api(api_method, arguments)
      data_json
    end
     
    get '/disable_domain' do
      api_method = 'disable-domain'				
      arguments = ['domain','why']
      data_json = call_remote_api(api_method, arguments)
      data_json
    end

    post '/modify_domain' do
      api_method = 'modify-domain'
      arguments = ['domain','user','pass','desp','email','quota','bw','template','plan']
      data_json = call_remote_api(api_method, arguments)
      data_json	
    end

    def call_remote_api(api_method, opts=[])
       api_command = build_remote_api_url(api_method,opts)
       output_json = `#{api_command}`
       #result = $?.success?
       output_json
    end
   

    #using string key to built md5 string to validate
    def authenticate()
      params_vals = ""
      opts = params.keys || []
      opts.delete "md5"
      opts.sort!
      opts.each do |opt|
        if params.has_key? opt
          val =  params[opt]
          val = "" if val == nil
          params_vals << val
        end
      end

      remote_ip = request.env['REMOTE_ADDR']
      access_ips = @@settings["access_server_ip"]

      key = @@settings['md5_key']
      params_vals << key
      md5_hex = Digest::MD5.hexdigest(params_vals)
      message = ''
      status = 1
      if params['md5'] != md5_hex
         status = 0
         message = 'MD5 string not matched'
         @@logger.info "requested md5: #{params['md5']}, but comptuered md5: #{md5_hex} from #{params_vals}"
      end

      if !access_ips.include?(remote_ip)
         status = 0
         message += "  #{remote_ip} rejected"
      end

      [status, message]

    end

    def build_remote_api_url(api_method,opts=[])
      remote_api_user = @@settings['virtualmin_user']
      remote_api_password = Base64.decode64(@@settings['virtualmin_password'])
      remote_api_ip = @@settings['virtualmin_ip']
      remote_api_port = @@settings['virtualmin_port']
      request_command ="wget -O - --quiet --http-user=#{remote_api_user} --http-passwd=#{remote_api_password} --no-check-certificate \"https://#{remote_api_ip}:#{remote_api_port}/virtual-server/remote.cgi?program=#{api_method}"

      str_opts = '&json=1'
      opts.each do |opt|
        if params.has_key? opt
          # TO-DO if need to encode the string using CGI.escape
          str_opts << "&#{opt}=#{CGI.escape(params[opt])}"
        end
      end
      request_command_query = request_command + str_opts + "\""
      mask_str = request_command_query.gsub(/--http-passwd=(.*) --no-check/,'--http-passwd=****** --no-check')
      @@logger.info mask_str
      request_command_query
    end
 
end

temp_path = File.dirname(__FILE__) + '/temp'
Dir.mkdir temp_path unless Dir.exist?(temp_path)
pfile = "#{temp_path}/webrick.pid"

server = ::Rack::Handler::WEBrick
[:INT, :TERM].each do |sig|
  trap(sig) do
    File.delete(pfile) if File.exist?(pfile)
    server.shutdown
  end
end


pid = Process.pid
server.run(MyServer, webrick_options) do |server|
  File.open(pfile, 'w'){ |f| f.write(pid.to_s) }
end
